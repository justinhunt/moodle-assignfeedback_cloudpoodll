{"version":3,"file":"correctionsmarkup.min.js","sources":["../src/correctionsmarkup.js"],"sourcesContent":["define(['jquery', 'core/log'], function ($, log) {\n    \"use strict\"; // jshint ;_;\n\n    log.debug('Corrections Markup: initialising');\n\n    return {\n        //controls\n\n        controls: {},\n\n        //class definitions\n        cd: {\n            correctionscontainer: 'asf_cp_corrections_cont',\n            insertclass: 'asf_cp_finediffinsertion',\n            passagewordclass: 'asf_cp_grading_passageword',\n            passagespaceclass: 'asf_cp_grading_passagespace',\n            //previously removed\n            wordclass: 'asf_cp_grading_correctionsword',\n            spaceclass: 'asf_cp_grading_correctionsspace',\n            originalprewordclass: 'asf_cp_grading_original_preword',\n            originalpostwordclass: 'asf_cp_grading_original_postword',\n            suggestionclass: 'asf_cp_corrections_suggestedword',\n            insertionclass: 'asf_cp_corrections_insertionword',\n            wordomittedclass: 'asf_cp_corrections_omittedword',\n            aiunmatched: 'asf_cp_aiunmatched',\n            aicorrected: 'asf_cp_aicorrected',\n            aiomitted: 'asf_cp_aiomitted',\n            aiinserted: 'asf_cp_aiinserted',\n            aisuggested: 'asf_cp_aisuggested',\n        },\n\n        options: {\n            errorwords: {},\n            grammarmatches: {},\n            suggestedwords: {},\n            insertioncount: 0\n        },\n\n        justmarkup: function (correctionsdiv, sessionerrors,sessionmatches,insertioncount) {\n            //register the controls\n            this.controls.correctionscontainer = $(correctionsdiv);\n            //set the options\n            this.options.suggestedwords = JSON.parse(sessionerrors);\n            this.options.grammarmatches = JSON.parse(sessionmatches);\n            this.options.insertioncount = insertioncount;\n            //do the markup\n            this.markup_suggestedwords();\n            this.markup_unmatchedwords();\n            //Original words displauy won't work in preview mode,\n            //because we don't have a marked up passage container on screen to get the original words from\n            //but it will work in the real view summary.\n            this.markup_originalwords();\n\n        },\n\n        init: function (config) {\n\n            //pick up opts from html (if any) and set them\n            var theid = '#' + config['id'];\n            var configcontrol = $(theid).get(0);\n            if (configcontrol) {\n                var opts = JSON.parse(configcontrol.value);\n                $(theid).remove();\n\n\n                if (opts['sessionerrors'] !== '') {\n                    this.options.suggestedwords = JSON.parse(opts['sessionerrors']);\n                } else {\n                    this.options.suggestedwords = {};\n                }\n                if (opts['sessionmatches'] !== '') {\n                    this.options.grammarmatches = JSON.parse(opts['sessionmatches']);\n                } else {\n                    this.options.grammarmatches  = {};\n                }\n\n                if (opts['insertioncount'] !== '') {\n                    this.options.insertioncount = opts['insertioncount'];\n                }else{\n                    this.options.insertioncount = 0;\n                }\n\n            } else if(config.hasOwnProperty('sessionerrors') &&\n                config.hasOwnProperty('sessionmatches') &&\n                config.hasOwnProperty('insertioncount')){\n\n                this.options.suggestedwords = JSON.parse(config['sessionerrors']);\n                this.options.grammarmatches = JSON.parse(config['sessionmatches']);\n                this.options.insertioncount = config['insertioncount'];\n\n            } else {\n                //if there is no config we might as well give up\n                return;\n            }\n\n            //register the controls\n            this.register_controls();\n\n            //markup suggested words\n            this.markup_suggestedwords();\n\n            //mark up unmatched words\n            this.markup_unmatchedwords();\n\n            //fill original words\n            this.markup_originalwords();\n\n            //register events\n            this.register_events();\n\n        },\n\n\n        register_controls: function () {\n\n            this.controls.correctionscontainer = $(\".\" + this.cd.correctionscontainer);\n\n        },\n\n        register_events: function () {\n            var that = this;\n\n            //classes to apply mouseover/click events to\n            var highlightclasses='.' + this.cd.wordclass + ',.' + this.cd.spaceclass +\n                ',.' + this.cd.originalprewordclass + ',.' + this.cd.originalpostwordclass;\n\n            //set up event handlers\n            this.controls.correctionscontainer.on('click',highlightclasses, function () {\n                var tpositions = $(this).attr('data-tpositions');\n                if (typeof tpositions === 'undefined' || tpositions === '') {\n                    return;\n                }\n\n                var correctiontype = '';//defaults to none .. its just highlighting\n                //any correction will be a suggestion but it might also be an insertion or an omission which overrides suggestion\n                if($(this).hasClass(that.cd.suggestionclass)){correctiontype='suggestion';}\n                if($(this).hasClass(that.cd.insertionclass)){correctiontype='insertion';}\n                if($(this).hasClass(that.cd.wordomittedclass)){correctiontype='omission';}\n\n                //perform highlighting\n                that.highlightoriginal(tpositions,correctiontype);\n                setTimeout(function () {\n                    that.dehighlightoriginal(tpositions);\n                }, 1000);\n            });\n\n            // Use mouseover event for highlighting\n            this.controls.correctionscontainer.on('mouseover', highlightclasses,  function () {\n                //if there is no transcript positions then we cannot highlight, so just return\n                var tpositions = $(this).attr('data-tpositions');\n                if (typeof tpositions === 'undefined' || tpositions === '') {return;}\n\n                var correctiontype = '';//defaults to none .. its just highlighting and not corrected\n                //any correction will be a suggestion but it might also be an insertion or an omission which overrides suggestion\n                if($(this).hasClass(that.cd.suggestionclass)){correctiontype='suggestion';}\n                if($(this).hasClass(that.cd.insertionclass)){correctiontype='insertion';}\n                if($(this).hasClass(that.cd.wordomittedclass)){correctiontype='omission';}\n                //perform highlighting\n                that.highlightoriginal(tpositions,correctiontype);\n            });\n\n            // Use mouseout event for de-highlighting\n            this.controls.correctionscontainer.on('mouseout',highlightclasses,  function () {\n                var tpositions = $(this).attr('data-tpositions');\n                if (typeof tpositions === 'undefined' || tpositions === '') {return;}\n                that.dehighlightoriginal(tpositions);\n            });\n        },\n\n        highlightoriginal: function (tpositionstring,correctiontype) {\n            var that = this;\n            var tpositions = tpositionstring.split(',');\n\n            //correction classes\n            var correctionsclasses = [];\n            correctionsclasses.push(that.cd.aicorrected);\n            if(correctiontype==='insertion') {\n                correctionsclasses.push(that.cd.aiinserted);\n            }else if(correctiontype==='omission') {\n                correctionsclasses.push(that.cd.aiomitted);\n            }else if (correctiontype==='suggestion') {\n                correctionsclasses.push(that.cd.aisuggested);\n            }\n\n            for (var i = 0; i < tpositions.length; i++) {\n                var tposition = tpositions[i];\n                if(correctiontype==='insertion') {\n                    //if the word is an insertion, then we only highlight spaces, because no word is altered in the original\n                    $('#' + that.cd.passagespaceclass + '_' + tposition).addClass(correctionsclasses);\n                } else {\n                    $('#' + that.cd.passagewordclass + '_' + tposition).addClass(correctionsclasses);\n                    //to highlight connecting spaces we check if we are between tpositions\n                    if(i < tpositions.length - 1) {\n                        $('#' + that.cd.passagespaceclass + '_' + tposition).addClass(correctionsclasses);\n                    }\n                }\n            }\n        },\n\n        dehighlightoriginal: function (tpositionstring) {\n            var that = this;\n            var correctionsclasses = [that.cd.aicorrected, that.cd.aiinserted, that.cd.aiomitted, that.cd.aisuggested];\n            var tpositions = tpositionstring.split(',');\n            $.each(tpositions, function (index, tposition) {\n                $('#' + that.cd.passagewordclass + '_' + tposition).removeClass(correctionsclasses);\n                $('#' + that.cd.passagespaceclass + '_' + tposition).removeClass(correctionsclasses);\n            });\n        },\n\n        markup_suggestedwords: function () {\n            var m = this;\n            //this will give all the words up until the last match (passage/corrections\n            $.each(m.options.suggestedwords, function (index) {\n                    $('.' + m.cd.correctionscontainer + ' #' + m.cd.wordclass + '_' + (m.options.suggestedwords[index].wordnumber)).addClass(m.cd.suggestionclass);\n                }\n            );\n            //sadly the above code only takes us to the last match. NOT to the last suggestion\n            //so from the last match to the end of passage (if there are any words left) we mark those up too\n            //we use the insertion count to guess the transcript indexes of end words. This is used to highlight passage on mouseover in view summary\n           //m.options.grammarmatches is js object, so we can't use array functions on it.\n            if(Object.keys(m.options.grammarmatches).length > 0) {\n                var lastpposition=0;\n                var lasttposition=0;\n                $.each(m.options.grammarmatches, function (index, lastmatch) {\n                    lastpposition = Number(lastmatch.pposition);\n                    lasttposition = Number(lastmatch.tposition);\n                });\n                var lastwordnumber = Number(lastpposition);\n                var tpositions = [];\n                for(var i = lasttposition + 1; i <= lasttposition + m.options.insertioncount + 1; i++) {\n                    tpositions.push(i);\n                }\n                var allwords = $('.' + m.cd.correctionscontainer + ' .' + m.cd.wordclass);\n                allwords.filter(function() {\n                    var wordNumber = Number($(this).data('wordnumber'));\n                    return wordNumber > lastwordnumber && !$(this).hasClass(m.cd.suggestionclass);\n                }).addClass(m.cd.suggestionclass).attr('data-tpositions', tpositions.join(','));\n            }\n\n        },\n\n        //now we step through all the matched words, and look for \"gaps\"\n        //we marked up new/replaced words in \"markup_suggestedwords\", but missing words can't be marked up(they are not there)\n        //so we highlight the space where the missing word would have been\n        //NB process is .. we step through each word in the corrected text. Each word has a tposition and pposition\n        //NB tposition is the position in the original text.\n        //NB pposition is the position in the corrected text.\n        //NB if the tposition of the current word in the corrected text has jumped since the previous word, then we have a gap\n        // .. \"tposition\" and \"pposition\" are a misleading terms here ..sorry\n        markup_unmatchedwords: function () {\n            var that = this;\n            if (this.options.grammarmatches) {\n                //we need a dummy prevmatch for the first loop\n                var prevmatch = {tposition: 0, pposition: 0};\n                $.each(this.options.grammarmatches, function (index, match) {\n                    //if there is a gap since the previous word match in the tposition\n                    //AND if we didn't just add a suggestion (which will cause a transcript mismatch too) then\n                    // it's a missing word (ie in original but not in the corrected text)\n                    //we want to get the prior space and highlight it to show its missing\n                    //eg original \"one two three four five\" corrected to \"one two four five\"\n                    // we want to highlight the space between \"two\" and \"four\" since the t postion has jumped by 2\n                    if((match.tposition - prevmatch.tposition)>1) {\n                        var missingwordspacenumber = match.pposition - 1;\n                        if(missingwordspacenumber>0) {\n                            //if we have a missing word space number greater than 0 (should add a 0 space actually)\n                            //and it's not either side of a suggested word, then highlight\n                            if (!$('#' + that.cd.wordclass + '_' + match.pposition).hasClass(that.cd.suggestionclass)&&\n                                !$('#' + that.cd.wordclass + '_' + missingwordspacenumber).hasClass(that.cd.suggestionclass)) {\n                                $('#' + that.cd.spaceclass + '_' + missingwordspacenumber).addClass(that.cd.wordomittedclass);\n                            }\n                            //compile a list of tpositions that we have missed. So we can highlight them on \"tap\"\n                            var tpositions = [];\n                            for(var i = prevmatch.tposition + 1; i < match.tposition; i++) {\n                                tpositions.push(i);\n                            }\n                            //loop through the words and spaces that make up the gap and record the tpositions\n                            //if it's just a missing word(s) with no corrections, we simply mark up the space with the tpositions\n                            var p_gapcount = (match.pposition - prevmatch.pposition) -1;\n                            if(p_gapcount ===0) {\n                                $('#' + that.cd.spaceclass + '_' + missingwordspacenumber).attr('data-tpositions', tpositions.join(','));\n                            }else{\n                                for(var z = prevmatch.pposition + 1; z < match.pposition; z++) {\n                                    $('#' + that.cd.spaceclass + '_' + z).attr('data-tpositions', tpositions.join(','));\n                                    $('#' + that.cd.wordclass + '_' + z).attr('data-tpositions', tpositions.join(','));\n                                }\n                            }\n                        }\n                    }else if(match.pposition - prevmatch.pposition > 1) {\n                        //if there is a gap in the pposition, then we have an extra word in the corrected text\n                        //we want to highlight the space where the extra word would have been in the original text\n                        //eg original \"one two three four five\" corrected to \"one two twopointfive three four five\"\n                        // we want to highlight the space between \"two\" and \"three\" in original since the p position has jumped by more than one\n                        for (var insertedword = prevmatch.pposition + 1; insertedword < match.pposition; insertedword++) {\n                            $('#' + that.cd.wordclass + '_' + insertedword).addClass(that.cd.insertionclass);\n                            $('#' + that.cd.wordclass + '_' + insertedword).attr('data-tpositions', prevmatch.tposition);\n                        }\n                    }\n\n                    //Always mark up the current words tposition as well\n                    $('#' + that.cd.wordclass + '_' + match.pposition).attr('data-tpositions', match.tposition);\n                    //store this match as the new prevmatch so on the next loop pass we can compare\n                    prevmatch = match;\n                });//end of $ each loop\n            }\n        },\n\n        //original CSS classes\n        //The original classes are to show the original passage word before or after the corrections word\n        //because of the layout, \"rewritten/added words\" [corrections] will show in green, after the original words [red]\n        //but \"removed(omitted) words\" [corrections] will show as a green space  after the original words [red]\n        // so the span layout for each word in the corrections is:\n        // [original_preword][correctionsword][original_postword][correctionsspace]\n        // suggested word: (original)He eat apples => (corrected)He eats apples =>\n        //    [original_preword: \"eat->\"][correctionsword: \"eats\"][original_postword][correctionsspace]\n        // removed(omitted) word: (original)He eat devours the apples=> (corrected) He devours the apples =>\n        //    [original_preword: ][correctionsword: \"He\"][original_postword: \"eat->\" ][correctionsspace: \" \"]\n        markup_originalwords: function () {\n            var that = this;\n            var processed_tpositions=[];\n            var allwordsspaces = $('.' + that.cd.correctionscontainer + ' .' + that.cd.wordclass +', .' + that.cd.correctionscontainer + ' .' + that.cd.spaceclass);\n            allwordsspaces.each(function () {\n                var wordnumber = Number($(this).data('wordnumber'));\n                if($(this).hasClass(that.cd.suggestionclass)||$(this).hasClass(that.cd.wordomittedclass)){\n                    var data_tpositions=$(this).attr('data-tpositions');\n\n                    //if we already added originals, we dont want to do it again,\n                    //eg (original)I the happy man => (corrections)I am a happy man\n                    // we only want to add original \"the\" on corrections \"am\" .. and not also on \"a\"\n                    if(processed_tpositions.includes(data_tpositions)){return;}\n                    processed_tpositions.push(data_tpositions);\n\n                    var tpositions = data_tpositions.split(',');\n                    var originalwords=[];\n                    for (var i = 0; i < tpositions.length; i++) {\n                        var tposition = tpositions[i];\n                        originalwords.push($('#' + that.cd.passagewordclass + '_' + tposition).text());\n                    }\n\n                    if(originalwords.length>0){\n                        var originaltext=originalwords.join(' ') + '->';\n                        if($(this).hasClass(that.cd.suggestionclass) && $(this).hasClass(that.cd.insertionclass)) {\n                            //if it is an inserted word a underscore(since original does not exist) shows before the current word\n                            //a space would be better, but then it would be 2 spaces which html collapses to 1 so it would be invisible\n                            $('#' + that.cd.originalprewordclass + '_' + wordnumber).text('_->');\n                            $('#' + that.cd.originalprewordclass + '_' + (wordnumber)).attr('data-tpositions', '');\n                        }else if($(this).hasClass(that.cd.suggestionclass)){\n                            //if it is a suggested word original word shows before the current word (green highlighted)\n                            $('#' + that.cd.originalprewordclass + '_' + wordnumber).text(originaltext);\n                            $('#' + that.cd.originalprewordclass + '_' + (wordnumber)).attr('data-tpositions',data_tpositions);\n                        }else if($(this).hasClass(that.cd.wordomittedclass)){\n                            //if it is an omitted word, original word shows after the current word (and before the green highlighted space)\n                            //since we are before the space we prepend a space so it doesn't run on after current word\n                            $('#' + that.cd.originalpostwordclass + '_' + (wordnumber)).text(' ' + originaltext);\n                            $('#' + that.cd.originalpostwordclass + '_' + (wordnumber)).attr('data-tpositions',data_tpositions);\n                        }\n                    }\n\n                }\n            });\n        },\n    };\n});"],"names":["define","$","log","debug","controls","cd","correctionscontainer","insertclass","passagewordclass","passagespaceclass","wordclass","spaceclass","originalprewordclass","originalpostwordclass","suggestionclass","insertionclass","wordomittedclass","aiunmatched","aicorrected","aiomitted","aiinserted","aisuggested","options","errorwords","grammarmatches","suggestedwords","insertioncount","justmarkup","correctionsdiv","sessionerrors","sessionmatches","JSON","parse","markup_suggestedwords","markup_unmatchedwords","markup_originalwords","init","config","theid","configcontrol","get","opts","value","remove","hasOwnProperty","register_controls","register_events","this","that","highlightclasses","on","tpositions","attr","correctiontype","hasClass","highlightoriginal","setTimeout","dehighlightoriginal","tpositionstring","split","correctionsclasses","push","i","length","tposition","addClass","each","index","removeClass","m","wordnumber","Object","keys","lastpposition","lasttposition","lastmatch","Number","pposition","lastwordnumber","filter","data","join","prevmatch","match","missingwordspacenumber","z","insertedword","processed_tpositions","data_tpositions","includes","originalwords","text","originaltext"],"mappings":"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"}