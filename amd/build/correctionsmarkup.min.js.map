{"version":3,"file":"correctionsmarkup.min.js","sources":["../src/correctionsmarkup.js"],"sourcesContent":["define(['jquery', 'core/log'], function ($, log) {\n    \"use strict\"; // jshint ;_;\n\n    log.debug('Corrections Markup: initialising');\n\n    return {\n        //controls\n\n        controls: {},\n\n        //class definitions\n        cd: {\n            correctionscontainer: 'asf_cp_corrections_cont',\n            insertclass: 'asf_cp_finediffinsertion',\n            passagewordclass: 'asf_cp_grading_passageword',\n            //previously removed\n            wordclass: 'asf_cp_grading_correctionsword',\n            spaceclass: 'asf_cp_grading_correctionsspace',\n            suggestionclass: 'asf_cp_corrections_suggestedword',\n            wordomittedclass: 'asf_cp_corrections_omittedword',\n            aiunmatched: 'asf_cp_aiunmatched',\n            aicorrected: 'asf_cp_aicorrected'\n        },\n\n        options: {\n            errorwords: {},\n            grammarmatches: {},\n            suggestedwords: {}\n        },\n\n        justmarkup: function (correctionsdiv, sessionerrors,sessionmatches) {\n            //register the controls\n            this.controls.correctionscontainer = $(correctionsdiv);\n            //set the options\n            this.options.suggestedwords = JSON.parse(sessionerrors);\n            this.options.grammarmatches = JSON.parse(sessionmatches);\n            //do the markup\n            this.markup_suggestedwords();\n            this.markup_unmatchedwords();\n\n        },\n\n        init: function (config) {\n\n\n\n            //pick up opts from html (if any) and set them\n            var theid = '#' + config['id'];\n            var configcontrol = $(theid).get(0);\n            if (configcontrol) {\n                var opts = JSON.parse(configcontrol.value);\n                log.debug(opts);\n                $(theid).remove();\n\n\n                if (opts['sessionerrors'] !== '') {\n                    this.options.suggestedwords = JSON.parse(opts['sessionerrors']);\n                } else {\n                    this.options.suggestedwords = {};\n                }\n                if (opts['sessionmatches'] !== '') {\n                    this.options.grammarmatches = JSON.parse(opts['sessionmatches']);\n                } else {\n                    this.options.grammarmatches  = {};\n                }\n\n\n            } else if(config.hasOwnProperty('sessionerrors') &&\n                config.hasOwnProperty('sessionmatches')){\n\n                this.options.suggestedwords = JSON.parse(config['sessionerrors']);\n                this.options.grammarmatches = JSON.parse(config['sessionmatches']);\n\n            } else {\n                //if there is no config we might as well give up\n                log.debug('Corrections Markup js: No config found on page. Giving up.');\n                return;\n            }\n\n            //register the controls\n            this.register_controls();\n\n            log.debug(this.options);\n\n            //markup suggested words\n            this.markup_suggestedwords();\n\n            //mark up unmatched words\n            this.markup_unmatchedwords();\n\n            //register events\n            this.register_events();\n\n        },\n\n\n        register_controls: function () {\n\n            this.controls.correctionscontainer = $(\".\" + this.cd.correctionscontainer);\n\n        },\n\n        register_events: function () {\n            var that = this;\n            //set up event handlers\n            this.controls.correctionscontainer.on('click','.' + this.cd.wordclass + ',.' + this.cd.spaceclass, function () {\n                var tpositions = $(this).attr('data-tpositions');\n                if (typeof tpositions === 'undefined' || tpositions === '') {return;}\n                that.highlightoriginal(tpositions);\n                setTimeout(function () {\n                    that.dehighlightoriginal(tpositions);\n                }, 1000);\n            });\n\n            // Use mouseover event for highlighting\n            this.controls.correctionscontainer.on('mouseover', '.' + this.cd.wordclass + ',.' + this.cd.spaceclass,  function () {\n                var tpositions = $(this).attr('data-tpositions');\n                if (typeof tpositions === 'undefined' || tpositions === '') {return;}\n                that.highlightoriginal(tpositions);\n            });\n\n            // Use mouseout event for de-highlighting\n            this.controls.correctionscontainer.on('mouseout','.' + this.cd.wordclass + ',.' + this.cd.spaceclass,  function () {\n                var tpositions = $(this).attr('data-tpositions');\n                if (typeof tpositions === 'undefined' || tpositions === '') {return;}\n                that.dehighlightoriginal(tpositions);\n            });\n        },\n\n        highlightoriginal: function (tpositionstring) {\n            var that = this;\n            var tpositions = tpositionstring.split(',');\n            $.each(tpositions, function (index, tposition) {\n                $('#' + that.cd.passagewordclass + '_' + tposition).addClass(that.cd.aicorrected);\n            });\n\n        },\n        dehighlightoriginal: function (tpositionstring) {\n            var that = this;\n            var tpositions = tpositionstring.split(',');\n            $.each(tpositions, function (index, tposition) {\n                $('#' + that.cd.passagewordclass + '_' + tposition).removeClass(that.cd.aicorrected);\n            });\n        },\n\n        markup_suggestedwords: function () {\n            var m = this;\n            $.each(m.options.suggestedwords, function (index) {\n                    $('.' + m.cd.correctionscontainer + ' #' + m.cd.wordclass + '_' + (m.options.suggestedwords[index].wordnumber)).addClass(m.cd.suggestionclass);\n                }\n            );\n        },\n\n        //now we step through all the matched words, and look for \"gaps\"\n        //we marked up new/replaced words in \"markup_suggestedwords\", but missing words can't be marked up(they are not there)\n        //so we highlight the space where the missing word would have been\n        //NB process is .. we step through each word in the corrected text. Each word has a tposition and pposition\n        //NB tposition is the position in the original text.\n        //NB pposition is the position in the corrected text.\n        //NB if the tposition of the current word in the corrected text has jumped since the previous word, then we have a gap\n        // .. \"tposition\" and \"pposition\" are a misleading terms here ..sorry\n        markup_unmatchedwords: function () {\n            var that = this;\n            if (this.options.grammarmatches) {\n                //we need a dummy prevmatch for the first loop\n                var prevmatch = {tposition: 0, pposition: 0};\n                $.each(this.options.grammarmatches, function (index, match) {\n                    //if there is a gap since the previous word match in the tposition\n                    //AND if we didn't just add a suggestion (which will cause a transcript mismatch too) then\n                    // it's a missing word (ie in original but not in the corrected text)\n                    //we want to get the prior space and highlight it to show its missing\n                    if((match.tposition - prevmatch.tposition)>1) {\n                        var missingwordspacenumber = match.pposition - 1;\n                        if(missingwordspacenumber>0) {\n                            //if we have a missing word space number greater than 0 (should add a 0 space actually)\n                            //and it's not either side of a suggested word, then highlight\n                            if (!$('#' + that.cd.wordclass + '_' + match.pposition).hasClass(that.cd.suggestionclass)&&\n                                !$('#' + that.cd.wordclass + '_' + missingwordspacenumber).hasClass(that.cd.suggestionclass)) {\n                                $('#' + that.cd.spaceclass + '_' + missingwordspacenumber).addClass(that.cd.wordomittedclass);\n                            }\n                            //compile a list of tpositions that we have missed. So we can highlight them on \"tap\"\n                            var tpositions = [];\n                            for(var i = prevmatch.tposition + 1; i < match.tposition; i++) {\n                                tpositions.push(i);\n                            }\n                            //loop through the words and spaces that make up the gap and record the tpositions\n                            //if it's just a missing word(s) with no corrections, we simply mark up the space with the tpositions\n                            var p_gapcount = (match.pposition - prevmatch.pposition) -1;\n                            if(p_gapcount ===0) {\n                                $('#' + that.cd.spaceclass + '_' + missingwordspacenumber).attr('data-tpositions', tpositions.join(','));\n                            }else{\n                                for(var z = prevmatch.pposition + 1; z < match.pposition; z++) {\n                                    $('#' + that.cd.spaceclass + '_' + z).attr('data-tpositions', tpositions.join(','));\n                                    $('#' + that.cd.wordclass + '_' + z).attr('data-tpositions', tpositions.join(','));\n                                }\n                            }\n                        }\n                    }\n                    //Always mark up the current words tposition as well\n                    $('#' + that.cd.wordclass + '_' + match.pposition).attr('data-tpositions', match.tposition);\n                    //store this match as the new prevmatch so on the next loop pass we can compare\n                    prevmatch = match;\n                });//end of $ each loop\n            }\n\n        },\n    };\n});"],"names":["define","$","log","debug","controls","cd","correctionscontainer","insertclass","passagewordclass","wordclass","spaceclass","suggestionclass","wordomittedclass","aiunmatched","aicorrected","options","errorwords","grammarmatches","suggestedwords","justmarkup","correctionsdiv","sessionerrors","sessionmatches","JSON","parse","markup_suggestedwords","markup_unmatchedwords","init","config","theid","configcontrol","get","opts","value","remove","hasOwnProperty","register_controls","this","register_events","that","on","tpositions","attr","highlightoriginal","setTimeout","dehighlightoriginal","tpositionstring","split","each","index","tposition","addClass","removeClass","m","wordnumber","prevmatch","pposition","match","missingwordspacenumber","hasClass","i","push","join","z"],"mappings":"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"}